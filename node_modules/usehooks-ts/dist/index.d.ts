import { Dispatch, SetStateAction, EffectCallback, RefObject, CSSProperties, useLayoutEffect, DependencyList } from 'react';

interface UseBooleanOutput {
    value: boolean;
    setValue: Dispatch<SetStateAction<boolean>>;
    setTrue: () => void;
    setFalse: () => void;
    toggle: () => void;
}
declare function useBoolean(defaultValue?: boolean): UseBooleanOutput;

type Handler$1 = (event: MouseEvent) => void;
declare function useClickAnyWhere(handler: Handler$1): void;

type CopiedValue = string | null;
type CopyFn = (text: string) => Promise<boolean>;
declare function useCopyToClipboard(): [CopiedValue, CopyFn];

interface UseCountdownType {
    seconds: number;
    interval: number;
    isIncrement?: boolean;
}
interface CountdownHelpers {
    start: () => void;
    stop: () => void;
    reset: () => void;
}
interface CountdownOption {
    countStart: number;
    intervalMs?: number;
    isIncrement?: boolean;
    countStop?: number;
}
interface CountdownControllers {
    startCountdown: () => void;
    stopCountdown: () => void;
    resetCountdown: () => void;
}
declare function useCountdown(countdownOption: UseCountdownType): [number, CountdownHelpers];
declare function useCountdown(countdownOption: CountdownOption): [number, CountdownControllers];

interface UseCounterOutput {
    count: number;
    increment: () => void;
    decrement: () => void;
    reset: () => void;
    setCount: Dispatch<SetStateAction<number>>;
}
declare function useCounter(initialValue?: number): UseCounterOutput;

interface UseDarkModeOutput {
    isDarkMode: boolean;
    toggle: () => void;
    enable: () => void;
    disable: () => void;
    set: (value: boolean) => void;
}
declare function useDarkMode(defaultValue?: boolean, localStorageKey?: string): UseDarkModeOutput;

declare function useDebounce<T>(value: T, delay?: number): T;

declare function useDocumentTitle(title: string): void;

declare function useEffectOnce(effect: EffectCallback): void;

interface Size {
    width: number;
    height: number;
}
declare function useElementSize<T extends HTMLElement = HTMLDivElement>(): [
    (node: T | null) => void,
    Size
];

declare function useEventCallback<Args extends unknown[], R>(fn: (...args: Args) => R): (...args: Args) => R;

declare function useEventListener<K extends keyof MediaQueryListEventMap>(eventName: K, handler: (event: MediaQueryListEventMap[K]) => void, element: RefObject<MediaQueryList>, options?: boolean | AddEventListenerOptions): void;
declare function useEventListener<K extends keyof WindowEventMap>(eventName: K, handler: (event: WindowEventMap[K]) => void, element?: undefined, options?: boolean | AddEventListenerOptions): void;
declare function useEventListener<K extends keyof HTMLElementEventMap, T extends HTMLElement = HTMLDivElement>(eventName: K, handler: (event: HTMLElementEventMap[K]) => void, element: RefObject<T>, options?: boolean | AddEventListenerOptions): void;
declare function useEventListener<K extends keyof DocumentEventMap>(eventName: K, handler: (event: DocumentEventMap[K]) => void, element: RefObject<Document>, options?: boolean | AddEventListenerOptions): void;

interface State<T> {
    data?: T;
    error?: Error;
}
declare function useFetch<T = unknown>(url?: string, options?: RequestInit): State<T>;

declare function useHover<T extends HTMLElement = HTMLElement>(elementRef: RefObject<T>): boolean;

interface ImageStyle {
    thumbnail: CSSProperties;
    fullSize: CSSProperties;
}
interface ImageOnLoadType {
    handleImageOnLoad: () => void;
    css: ImageStyle;
}
declare function useImageOnLoad(): ImageOnLoadType;

interface Args extends IntersectionObserverInit {
    freezeOnceVisible?: boolean;
}
declare function useIntersectionObserver(elementRef: RefObject<Element>, { threshold, root, rootMargin, freezeOnceVisible, }: Args): IntersectionObserverEntry | undefined;

declare function useInterval(callback: () => void, delay: number | null): void;

declare function useIsClient(): boolean;

declare function useIsFirstRender(): boolean;

declare function useIsMounted(): () => boolean;

declare const useIsomorphicLayoutEffect: typeof useLayoutEffect;

declare global {
    interface WindowEventMap {
        'local-storage': CustomEvent;
    }
}
type SetValue$1<T> = Dispatch<SetStateAction<T>>;
declare function useLocalStorage<T>(key: string, initialValue: T): [T, SetValue$1<T>];

type UseLockedBodyOutput = [boolean, (locked: boolean) => void];
declare function useLockedBody(initialLocked?: boolean, rootId?: string): UseLockedBodyOutput;

type MapOrEntries<K, V> = Map<K, V> | [K, V][];
interface Actions<K, V> {
    set: (key: K, value: V) => void;
    setAll: (entries: MapOrEntries<K, V>) => void;
    remove: (key: K) => void;
    reset: Map<K, V>['clear'];
}
type Return<K, V> = [Omit<Map<K, V>, 'set' | 'clear' | 'delete'>, Actions<K, V>];
declare function useMap<K, V>(initialState?: MapOrEntries<K, V>): Return<K, V>;

declare function useMediaQuery(query: string): boolean;

type Handler = (event: MouseEvent) => void;
declare function useOnClickOutside<T extends HTMLElement = HTMLElement>(ref: RefObject<T>, handler: Handler, mouseEvent?: 'mousedown' | 'mouseup'): void;

type Value<T> = T | null;
declare function useReadLocalStorage<T>(key: string): Value<T>;

declare function useScreen(): Screen | undefined;

type UseScriptStatus = 'idle' | 'loading' | 'ready' | 'error';
interface UseScriptOptions {
    shouldPreventLoad?: boolean;
    removeOnUnmount?: boolean;
}
declare function useScript(src: string | null, options?: UseScriptOptions): UseScriptStatus;

declare global {
    interface WindowEventMap {
        'session-storage': CustomEvent;
    }
}
type SetValue<T> = Dispatch<SetStateAction<T>>;
declare function useSessionStorage<T>(key: string, initialValue: T): [T, SetValue<T>];

declare function useSsr(): {
    isBrowser: false | HTMLElement;
    isServer: boolean;
};

interface Helpers {
    goToNextStep: () => void;
    goToPrevStep: () => void;
    reset: () => void;
    canGoToNextStep: boolean;
    canGoToPrevStep: boolean;
    setStep: Dispatch<SetStateAction<number>>;
}
declare function useStep(maxStep: number): [number, Helpers];

type TernaryDarkMode = 'system' | 'dark' | 'light';
interface UseTernaryDarkModeOutput {
    isDarkMode: boolean;
    ternaryDarkMode: TernaryDarkMode;
    setTernaryDarkMode: Dispatch<SetStateAction<TernaryDarkMode>>;
    toggleTernaryDarkMode: () => void;
}
declare function useTernaryDarkMode(localStorageKey?: string): UseTernaryDarkModeOutput;

declare function useTimeout(callback: () => void, delay: number | null): void;

declare function useToggle(defaultValue?: boolean): [boolean, () => void, Dispatch<SetStateAction<boolean>>];

declare function useUpdateEffect(effect: EffectCallback, deps?: DependencyList): void;

interface WindowSize {
    width: number;
    height: number;
}
declare function useWindowSize(): WindowSize;

export { type Actions, type MapOrEntries, type UseScriptOptions, type UseScriptStatus, useBoolean, useClickAnyWhere, useCopyToClipboard, useCountdown, useCounter, useDarkMode, useDebounce, useDocumentTitle, useEffectOnce, useElementSize, useEventCallback, useEventListener, useFetch, useHover, useImageOnLoad, useIntersectionObserver, useInterval, useIsClient, useIsFirstRender, useIsMounted, useIsomorphicLayoutEffect, useLocalStorage, useLockedBody, useMap, useMediaQuery, useOnClickOutside, useReadLocalStorage, useScreen, useScript, useSessionStorage, useSsr, useStep, useTernaryDarkMode, useTimeout, useToggle, useUpdateEffect, useWindowSize };
